# 3 DoF Arm
## Arm Simulation
To run the simulation with the controller, enter the directory that contains the arm_simulator executable (e.g. /build/examples/arm/) and run the following:
`./arm_simulator`

## Arm Code Generation
To generate code for the model, enter the directory of the arm_codegen executable (e.g. /build/examples/arm/) and run the following:
`./arm_codegen <code generation destination>`

## Explanation of Current Code (Damian - 7/11/2023)

This example presents the new design for creating OSC controllers. We create control laws that solve the following program at each instance

$$
\begin{align}
u \in \arg\min_{\ddot{q},u,\lambda_c} & \sum_i w_i || J_i \ddot{q} + \dot{J}_i \dot{q} + \ddot{x}_d ||^2 + w_{u} || u ||^2\\
\textrm{s.t.} \quad & M(q) \ddot{q} + h(q,\dot{q}) = B(q) u + J_c^T \lambda_c\\
& \lambda_c \in \mathcal{F}_c\\
& u\_{\min} \le u \le u\_{\max}\\
\end{align}
$$

Where our desired task accelerations $\ddot{x}_d$ are encoded as PD outputs from the task error

$$e_i = x_i - r_i$$

such that
$$\ddot{x}_d = K_p e_i + K_d \dot{e}_i$$

We adopt a model-based approach such that all information such as dynamics, kinematics, tasks and constraints are contained by a single `Model` class. In the OSC namespace, this is given by the class `controller::osc::Model` (in `/include/controllers/osc/model.h`). Controllers are then constructed by passing a reference to a `Model` instance, no further additions are required as all is handled by the `Model` class (see `/examples/arm/sim/simulate.cc`).

To create a model for an OSC controller, we must first create a new Model class for that particular system, by deriving it from the appropriate model class. In our arm case, we create an `ArmModel` class that inherits from the `Model` class for OSC controllers, as we want to make an OSC controller (defined in ./controller/osc.h). This class allows us to now add tasks, constraints and end-effector task constraints (ones that can include contact forces). Whilst we have only included this model class in a header file, for more sophisticated models, this can be easily split across both a header and source file(s).

From this point, a few functions are required to be implemented, and the code will not compile without them (as they are pure virtual classes in the base `Model` class). The first being the dynamics functions that must compute $M(q)$, $h(q, \dot{q})$ and $B(q)$, these are `ComputeMassMatrix`, `ComputeBiasVector` and `ComputeActuationMap`, where their function signatures are shown in `include/controllers/model.h`. These can be implemented in any way, in our example, these have been generated by casADi, so we simply pass the necessary information to each function to return their respective data. You could do this infinitely many other ways, including through manually filling the matrics in. Currently these are all dense matrices/vectors being passed, we may move to sparse or structured matrices later on but we will stick with dense matrices for the time-being.

Adding a generic task, one that can be expressed as follows:

$$
\begin{aligned}
x &= f(q)\\
\dot{x} &= \frac{\partial f}{\partial q} \dot{q} := J(q) \dot{q}\\
\ddot{x} &= J(q) \ddot{q} + \dot{J}(q) \dot{q}
\end{aligned}
$$

can be achieved either creating a `controller::osc::Task` object, and adding it to the `TaskMap` of the `Model` class (e.g. how we implement the joint limits task), or by calling the `AddTask` function of the `Model` class, where we must provide a name, dimension of the task, the sizes of the model (i.e $n_q,\,n_{\dot{q}}$) as well as a callback function that gets called when the task must be updated. This callback function has a signature given in `./include/controller/osc/task.h`, which the function must use, it must compute the task $x$, the Jacobian $J(q)$ and the expression $\dot{J}(q)\dot{q}$ (all dense, as before). We see two implementations in our example, with `WristAngleTask` being a hand-made generation and `TipPositionTask` being a code-generated implementation. The callback function used for `TipPositionTask` is declared as static for easier passing of the function pointer, however this can also be done through the use of `std::bind`, where the pointer to the class is passed as the first parameter, similarly to when ROS callbacks are made.

After calling `AddTask`, it is added to the `TaskMap` similarly to our first method. From this point, each task is accessable by their given name, by calling `GetTask("<name>")`. You can then set several parameters for this task such as its relative weighting $w_i$, the gains $K_p$ and $K_d$ for error corrections. Currently, we assemble all the tasks within the constructor of the given model, allowing us to neatly include it in a simulation ready-to-go as in `/examples/arm/sim/simulate.cc`.

We also have a `UpdateReferences` function that can be implemented that is called every time the controller updates, this way, references for the tasks can be updated. You could also modify the weights and other task parameters here if need be (this might require a name change for this function).

Similarly to the addition of tasks, we can also do the same for holonomic constraints and end-effector tasks that can switch in and out of contact. Constraints are currently under development, where the controller will either consider the associated constraint forces explictly in the above program or implictly by null-space projection (see `/src/osc/run_osc.cc`). End-effector tasks are very similar to the addition and handling of normal tasks, with the exception that if they're under contact, they can be specified to remain still and experience non-zero constraint force (see `/include/osc/tasks/ee_task.h` and `/src/osc/tasks/ee_task.cc`).

To modify the weighting of the control output $u$ (i.e. $w_u$), this is adjusted by the OSC controller class, by setting the weight through the member function `SetTorqueWeight(<weight>)`.
